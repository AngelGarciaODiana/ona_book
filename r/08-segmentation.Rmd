# Components, Communities and Cliques {#community}

The study of group dynamics would be pretty ineffective if we were not able to identify and study important subgroups.  Networks of people are often made up of subsets that interact more intensely among each other than they do with the rest of the network, and it is often very important in research and analysis to identify or approximate these subsets as best as possible so that they can be studied more closely.  In complex networks, this is not an easy task.  Most of the computational methods we have available to us for finding `r if (knitr::is_latex_output()) '\\index{community}'`densely connected subsets of vertices (usually called *communities*) are iterative approximations which make use of heuristics^[Heuristics are methodological 'shortcuts' which can vastly reduce the complexity of a problem but usually sacrifice some element of accuracy in doing so.] and are rarely `r if (knitr::is_latex_output()) '\\index{graph!clustering}'`100% accurate^[Many problems of graph 'clustering' --- that is, finding partitions of a graph that maximise intra-group density but minimize between-group density --- have already been shown to be NP-hard].  However, in the study of networks in the organizational sciences, we do not need high levels of precision to be able to draw valuable insights, and therefore these modern approximation techniques are very powerful tools for us to have at our disposal.

In the work we have done thus far in the book, we have already been exposed to `r if (knitr::is_latex_output()) '\\index{graph!subgraph}'`subgraphs --- we have used induced vertex subgraphs containing a specified set of vertices and all edges between them.  However, in these situations we were able to specify the precise subset of vertices that we were interested in.  In this chapter we will look at methods to identify or 'detect' subsets of vertices based on certain properties of the induced subgraphs of those vertices.  We will start with simpler problems such as identifying subsets of vertices which are completely disconnected from others, and then we will proceed to look at graph `r if (knitr::is_latex_output()) '\\index{partition (of a graph)}'`partitioning and the identification of cliques and communities of vertices which, though not disconnected from other parts of the graph, have higher levels of density between each other than with the rest of the network.

## Theory of components, partitions and clusters

### Connected components of graphs

`r if (knitr::is_latex_output()) '\\index{graph!connected}'`We learned earlier that a graph $G$ is **connected** if a path exists between any pair of vertices $u$ and $v$ in $G$.  If $G$ is a directed graph, we say $G$ is `r if (knitr::is_latex_output()) '\\index{graph!weakly connected}'`**weakly connected** if it would be connected when viewed as an undirected graph.  We say that $G$ is `r if (knitr::is_latex_output()) '\\index{graph!strongly connected}'`**strongly connected** if a path exists *from* $u$ *to* $v$ for any pair of vertices $u$ and $v$ in $G$. We say $G$ is `r if (knitr::is_latex_output()) '\\index{graph!unilaterally connected}'`**unilaterally connected** if a path exists *either* from $u$ and $v$ *or* from $v$ to $u$ for any pair of vertices $u$ and $v$ in $G$.  

A `r if (knitr::is_latex_output()) '\\index{connected component}'`**connected component** of a graph is a connected subset of vertices, none of which are connected to any other vertex in the graph.  As an example, the undirected graph in Figure \@ref(fig:component1) consists of three connected components, each with three vertices.  In the directed graph in Figure \@ref(fig:component2), one component is strongly connected ($A \longrightarrow B \longrightarrow C \longrightarrow A$), one is unilaterally connected ($D \longrightarrow E \longrightarrow F$) and the third is weakly connected ($G \longrightarrow I \longleftarrow H$).

```{r component1, echo = FALSE, fig.align = "center", fig.cap = "A graph with three connected components, each containing three vertices"}
library(igraph)
library(ggraph)

edges <- data.frame(
  from = c("A", "B", "C", "D", "E", "G", "H"),
  to = c("B", "C", "A", "E", "F", "I", "I")
)

comp1 <- igraph::graph_from_data_frame(edges, directed = FALSE)
comp2 <- igraph::graph_from_data_frame(edges, directed = TRUE)

set.seed(123)
ggraph(comp1, layout = "kk") +
  geom_edge_link(color = "grey") +
  geom_node_point(color = "lightblue", size = 6) +
  geom_node_text(aes(label = name)) +
  theme_void()
```

```{r component2, echo = FALSE, fig.align = "center", fig.cap = "A directed graph with three connected components, one strongly connected, one weakly connected and one unilaterally connected"}
set.seed(123)
ggraph(comp2, layout = "kk") +
  geom_edge_link(color = "grey", arrow = arrow()) +
  geom_node_point(color = "lightblue", size = 6) +
  geom_node_text(aes(label = name)) +
  theme_void()
```

Connected components of disconnected graphs are important to identify, because many of the measures we have learned so far break down for disconnected graphs.  For example, the diameter of a disconnected graph is theoretically defined as infinite by mathematical convention, but this is not a useful practical measure. Usually when we want to know the diameter of a graph, we want to understand the largest *finite* distance between any two vertices,  which translates to the diameter of the largest connected component in the graph.  Therefore most calculations of diameter in disconnected graphs require us to be able to identify the largest connected component. 

It is not too difficult to think of an algorithm that can determine all the connected components of a graph.  If you are interested in this see the exercises at the end of this chapter.

:::{.thinkahead data-latex=""}
**Playing around**:  Go back and try to find some examples in earlier chapters of graphs that are disconnected, and calculate the `r if (knitr::is_latex_output()) '\\index{diameter (of a graph)}'`diameter that is returned by the functions in R or Python packages.  For example, you could try the Random Acts of Pizza graph from the exercises at the end of Chapter \@ref(viz-graphs) or the graph of reported friendships from the `schoolfriends` data set at the end of the previous chapter.  What do diameter functions return for these graphs?
:::

### Vertex partitioning

`r if (knitr::is_latex_output()) '\\index{partition (of a graph)}'`Often graphs will be connected but we still want to divide the vertices up into mutually exclusive subgroups of interest.  Such a division is called a **partition** of a graph.  In a partition, all vertices must be in one and only one subgroup.  Partitions are created through making cuts in a graph.

`r if (knitr::is_latex_output()) '\\index{cut (of a graph)}'`A **cut** in a graph $G$ is a set of edges that divide the vertices of $G$ into two disjoint subsets.  The number of edges is known as the `r if (knitr::is_latex_output()) '\\index{cut size}'`*size* of the cut.  In Figure \@ref(fig:cutex), edges e3, e4 and e5 divide the graph into two disjoint connected sets and represents a cut of size 3. 

A `r if (knitr::is_latex_output()) '\\index{minimum cut}'`**minimum cut** is a cut where no other cut exists in $G$ with a smaller number of edges.  In Figure \@ref(fig:cutex), it should not be difficult to see that mimimum cuts have size 1 and can be achieved with either e1 or e2.  In both cases these minimum cuts divide the graph into a connected component and an isolate^[Maximum cuts are cuts where no other cuts exist with a greater number of edges.  Maximum cuts in graphs are extremely challenging to determine. Luckily, we rarely need them in organizational network analysis.].  

```{r cutex, echo = FALSE, fig.align = "center", fig.cap = "Cuts are defined by edges that split the vertices of a graph into disjoint subsets"}
cutex_edges <- data.frame(
from = c("A", "B", "D", "E", "F", "D", "E"),
to = c("C", "C", "C", "C", "C", "F", "F"),
label = c("e1", "e2", "e3", "e4", "e5", "e6", "e7")
)

cutex <- igraph::graph_from_data_frame(cutex_edges, directed = FALSE)

set.seed(123)
ggraph(cutex, layout = "fr") +
  geom_edge_link(aes(label = label), color = "grey") +
  geom_node_point(color = "lightblue", size = 6) +
  geom_node_text(aes(label = name)) +
  theme_void()

```
A partition of a graph $G$ is obtained through a series of cuts.  For example, if we make a cut using e3, e5 and e7 in Figure \@ref(fig:cutex), we split the graph into two disjoint connected graphs.  If we then make a further cut using e1, we split the graph into three disjoint sets: two disjoint connected sets and an isolate. 

In directed graphs, cuts can be defined according to the direction of edges, and in weighted graphs, minimum cuts can be determined through the weights of edges. The most popular algorithm for determining the minimum cut of a graph is the Stoer-Wagner algorithm (@stoer).

### Vertex clustering and community detection

Vertex `r if (knitr::is_latex_output()) '\\index{graph!clustering}'`**clustering** refers to the process of partitioning a graph in order to satisfy a certain objective. Most commonly in organizational network analysis, that objective is to achieve a high `r if (knitr::is_latex_output()) '\\index{density (of a graph)}'`edge density between the vertices inside a cluster, and a low edge density between vertices that are in different clusters.  Such highly connected clusters are usually referred to as `r if (knitr::is_latex_output()) '\\index{community}'`**communities** and the process of determining optimal communities in a graph is knows as `r if (knitr::is_latex_output()) '\\index{community detection}'`**community detection** or **community discovery**^[The meaning of 'high' and 'low' edge density is relative and really depends on the nature of the graph, and algorithms will do their best to find communities which maximize the difference between in-community density and cross-community density, even though some or all of these communities may not end up having have particularly high edge density].  Community detection is an unsupervised process.  When we perform community detection on a graph, we do not know in advance how many communities we seek to find or the size of those communities.

The most commonly used (and fastest) community detection algorithm is the `r if (knitr::is_latex_output()) '\\index{algorithm!Louvain}'`Louvain algorithm.  The Louvain algorithm  partitions a graph into subsets of vertices by trying to maximize the `r if (knitr::is_latex_output()) '\\index{modularity}'`*modularity* of the graph.  Modularity measures how dense the connections are within subsets of vertices in a graph by comparing the density to that which would be expected from a random graph.  In an unweighted and undirected graph, modularity takes a value between -0.5 and +1.  Any value above zero means that the the vertices inside the subgroups are more densely connected than would be expected by chance.  The higher the modularity of a graph, the more connected the vertices are inside the subgroups compared to between the subgroups, and therefore the more certain we can be that the subgroups represent genuine communities of more intense connection.  The approximate steps of the Louvain algorithm are in two phases as follows:

1.  The algorithm starts with each vertex in its own community.
2.  Vertices are moved into other communities and modularity is calculated.
3.  When the algorithm reaches a point where further vertex moves do not increase modularity, it finishes its first phase.
4.  In the second phase, the communities resulting from the first phase are aggregated to form a simpler pseudograph where each vertex represents a community, where loop edges on a vertex are weighted by the total number of edges inside that community, and where edges between vertices are weighted by the total number of edges between those communities^[This also works with weighted edges, assuming that weights represent 'closeness' of connection, which they usually do in organizational contexts.].  In this heuristic step, vertices are moved in this simpler graph with the aim of improving modularity.  That is, communities may be combined if modularity is improved.
5.  Phases 1 and 2 are repeated until modularity cannot be further improved.

A more recently developed community detection algorithm which improves on the Louvain algorithm is the `r if (knitr::is_latex_output()) '\\index{algorithm!Leiden}'`Leiden algorithm.  The Leiden algorithm operates similarly to Louvain, but has an additional refinement process at the end of the first phase which helps increase the options for improved modularity in the second phase.  The Leiden algorithm will always achieve results as good as the Louvain algorithm, and in many cases may detect communities which are better connected than those detected by Louvain.

Both the Louvain and Leiden algorithms are good options for performing community detection in an organizational context.  However, there are numerous other options, many of which are available in common data science packages.   For example, the `r if (knitr::is_latex_output()) '\\index{algorithm!Girvan-Newman}'`Girvan-Newman algorithm operates in a very different way by starting with an entire graph and progressively removing important edges to potentially reveal high modularity subgroups.  For a more detailed reference on the Louvain and Leiden algorithms see @traag and for more general insight into a broader range of community detection algorithms, see @yang. 

One important aspect of community detection which is often not understood is that community detection algorithms classify vertices into subgroups, but offer no direct insight into the *nature* of those subgroups.  Further analytic techniques need to be applied to help describe the subgroups in a meaningful way.  For example, the subgroups could be compared to known 'ground truth' characteristics of the network (such as department in the `workfrance` graph or class in the `schoolfriends` graph).  We will examine this using an example later in this chapter.

### Cliques

`r if (knitr::is_latex_output()) '\\index{clique (in a graph)}'`A **clique** is a subset of vertices in an undirected graph whose induced subgraph is complete.  That is, the induced subgraph has an edge density of 1.  This is best understood as the most intense possible type of community in an undirected graph.  A `r if (knitr::is_latex_output()) '\\index{maximal clique}'`**maximal clique** is a clique which cannot be extended by adding another vertex.  A **largest clique** is a clique with the greatest number of vertices of all cliques in the graph.  

In Figure \@ref(fig:cutex), the following are maximal cliques:  $B \longleftrightarrow C$, $A \longleftrightarrow C$, $C \longleftrightarrow E \longleftrightarrow F$ and $C \longleftrightarrow D \longleftrightarrow F$ because no other vertex can be added to these cliques without creating an incomplete graph.  $C \longleftrightarrow E \longleftrightarrow F$ and $C \longleftrightarrow D \longleftrightarrow F$ are largest cliques because there is no clique in the graph that has more than three vertices.

Finding a single maximal clique in an undirected graph is not a complex problem and can be done quickly using a standard search algorithm starting on an arbitrary vertex. However, finding maximal cliques of a specified size, or all maximal cliques, as well as finding largest cliques, are problems whose complexity increases with the size and density of a graph.  Care should be taken in attempting these algorithms on very large graphs. 

:::{.thinkahead data-latex=""}
**Thinking ahead:**  Go back to the graph of `r if (knitr::is_latex_output()) "\\index{Zachary's Karate Club}"`*Zachary's Karate Club* in Chapter \@ref(viz-graphs).  Can you identify some maximal cliques?  What do you think is the size of the largest clique?  Thinking about this will give you a sense of how hard the largest clique problem might be on very large graphs.  We will use this as an example later in the chapter.
:::


## Finding components, communities and cliques using R

### Finding connected components of disconnected graphs

`r if (knitr::is_latex_output()) '\\index{connected component!calculating in R}'`
To illustrate the `components()` function in `igraph` we will load up the `r if (knitr::is_latex_output()) '\\index{data sets!schoolfriends@\\texttt{schoolfriends}}'``schoolfriends` edgelist dataset from an earlier chapter.  We will use reported friendships, create a directed graph and visualize it as in Figure \@ref(fig:viz-schoolfriends-rp).

```{r viz-schoolfriends-rp, fig.align = "center", fig.cap = "The directed graph of reported friendships from our French high school"}
library(igraph)
library(ggraph)
library(dplyr)

# get schoolfriends edgelist
schoolfriends_edgelist <- read.csv(
  "https://ona-book.org/data/schoolfriends_edgelist.csv"
)

# just use reported friendships
schoolfriends_reported <- schoolfriends_edgelist |> 
  dplyr::filter(type == "reported")

# create directed graph
schoolfriends_rp <- igraph::graph_from_data_frame(schoolfriends_reported)

# visualize
set.seed(123)
ggraph(schoolfriends_rp) + 
  geom_edge_link(color = "grey",
                 arrow = arrow(length = unit(0.2, "cm"))) +
  geom_node_point(size = 2, color = "blue") +
  theme_void()
```

We can see some connected components in this disconnected graph.  We can use the `components()` function to classify the vertices into the connected components.   This function generates a list containing the following vectors:

* `membership`, which is a vector assigning each vertex to a numbered component
* `csize`, which returns the size of each component
* `no`, which is the number of connected components

Let's verify the latter two:

```{r}
# get weakly connected components (mode ignored if undirected)
schoolfriends_components <- igraph::components(schoolfriends_rp, 
                                               mode = "weak")

# how many components?
schoolfriends_components$no
```

```{r}
# size of components
schoolfriends_components$csize
```

We can use the membership to assign a `component` property and then visualize with the vertices colored by component, as in Figure \@ref(fig:component-color).

```{r component-color, fig.align = "center", fig.cap = "The reported `schoolfriends` graph color coded by its (weakly) connected components"}
# assign component property
V(schoolfriends_rp)$component <- schoolfriends_components$membership

# visualize
ggraph(schoolfriends_rp) + 
  geom_edge_link(color = "grey", 
                 arrow = arrow(length = unit(0.2, "cm"))) +
  geom_node_point(size = 2, aes(color = as.factor(component))) +
  labs(color = "Component") +
  theme_void()
```

:::{.thinkahead data-latex=""}
**Playing around:** Weakly connected components of a directed graph are easier to spot with the naked eye compared to strongly connected components.  Why?  Remind yourself of the definition of weakly connected from earlier in this chapter.  Try to repeat this analysis to visualize all strongly connected components in the reported `schoolfriends` graph and see the difference.
:::

### Partioning and community detection in R

`r if (knitr::is_latex_output()) '\\index{data sets!karate@\\texttt{karate}}'`For the next few examples we will return to *Zachary's Karate Club* network from Chapter \@ref(viz-graphs).  Let's load up and visualize that undirected graph and mark the known leading actors Mr Hi and John A with larger vertices, as in Figure \@ref(fig:karate8).

```{r karate8, fig.align = "center", fig.cap = "Zachary's Karate Club graph with Mr Hi and John A indicated with larger vertices"}
# get karate edgelist
karate_edges <- read.csv("https://ona-book.org/data/karate.csv")

# create undirected graph
karate <- igraph::graph_from_data_frame(karate_edges, directed = FALSE)

# color John A and Mr Hi differently
V(karate)$leader <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"), 1, 0)

# visualize
set.seed(123)
ggraph(karate, layout = "fr") +
  geom_edge_link(color =  "grey") +
  geom_node_point(aes(size = as.factor(leader)), color = "blue",
                  show.legend = FALSE) +
  theme_void()
```

`r if (knitr::is_latex_output()) '\\index{cut (of a graph)!caclulating in R}'`
Minimum cuts in graphs can be found using the `min_cut()` function in `igraph`.  This will return the number of edges in the minimum cut, unless you use the `value.only = FALSE` argument, in which case it will return more information on the cut,

```{r, eval = FALSE}
igraph::min_cut(karate, value.only = FALSE)
```

`r if (knitr::is_latex_output()) '\\footnotesize'`
```{r, echo = FALSE}
igraph::min_cut(karate, value.only = FALSE)
```
`r if (knitr::is_latex_output()) '\\normalsize'`

We see that a minimum cut exists of size 1 between Mr Hi and Actor 12.

`r if (knitr::is_latex_output()) '\\index{community detection!calculating in R}'`
The Louvain community detection algorithm can be run using the `cluster_louvain()` function.  `weights` can be added as an argument, or will be used by default if the graph has a `weight` edge attribute (set `weight = NA` to avoid this).   This will produce a list of community groups.  The best way to record the resulting community membership is to assign it as a vertex property using the `membership()` function.    

```{r}
# detect communities using Louvain
communities <- cluster_louvain(karate)

# assign as a vertex property
V(karate)$community <- membership(communities)
```

`r if (knitr::is_latex_output()) '\\index{modularity!calculating in R}'`Before visualizing the communities, we can see how many they are and their size^[We can also see the modularity of the partition by calling the `modularity()` function.]:

```{r}
sizes(communities)
```

We have four detected communities of varying sizes.  As before, we can color code to visualize these, as in Figure \@ref(fig:karate-communities).

```{r karate-communities, fig.align="center", fig.cap = "Communities of Zachary's Karate Club as detected by the Louvain algorithm"}
set.seed(123)
ggraph(karate, layout = "fr") +
  geom_edge_link(color =  "grey") +
  geom_node_point(aes(size = as.factor(leader), color = as.factor(community)),
                  show.legend = FALSE) +
  theme_void()
```
:::{.thinkahead data-latex=""}
**Playing around:**. Try playing around with some of the other community detection methods available in `igraph` using the `karate` example.  How different are the results?  For example, try `cluster_edge_betweenness()` (the Girvan-Newman algorithm) or `cluster_infomap()` or any other methods that begin with `cluster`.
:::

### Finding cliques in R

`r if (knitr::is_latex_output()) '\\index{clique (in a graph)!calculating in R}'`
`r if (knitr::is_latex_output()) '\\index{maximal clique!calculating in R}'`
The `cliques()` and `max_cliques()` function in `igraph` identifies all cliques or maximal cliques respectively, with a specified maximum or minimum size if desired.  It is advisable to specify a size for cliques of interest because otherwise a long list might be returned, including many single node cliques.

```{r}
max_cliques(karate, min = 5, max = 5)
```

The `largest_cliques()` function finds all largest cliques in a graph.

```{r}
largest_cliques(karate)
```

We see that the maximal cliques of size 5 that we identified are also the largest cliques in the `karate graph`, and they have four out of 5 vertices in common.  The function `clique_num()` returns the size of the largest clique.

```{r}
clique_num(karate)
```


## Finding components, communities and cliques using Python

### Finding connected components using Python

`r if (knitr::is_latex_output()) '\\index{connected component!calculating in Python}'`
For *undirected graphs*, the `networkx` function `number_connected_components()` returns the number of connected components in the graph while the `connected_components()` function returns the vertices in each connected component.  

For *directed graphs*, similar functions identify weakly and strongly connected components.  Let's use the reported friendships from the `schoolfriends` data set as an example.

```{python}
import pandas as pd
import networkx as nx

# get schoolfriends edgelist
schoolfriends_edges = pd.read_csv(
  "https://ona-book.org/data/schoolfriends_edgelist.csv"
)

# use only reported friendships
schoolfriends_reported = schoolfriends_edges[
  schoolfriends_edges.type == "reported"
]

# create directed graph
schoolfriends_rp = nx.from_pandas_edgelist(
  schoolfriends_reported,
  source = "from",
  target = "to",
  create_using=nx.DiGraph
)

# number of weakly connected components
nx.number_weakly_connected_components(schoolfriends_rp)
```


```{python}
# create component subgraphs 
components = nx.weakly_connected_components(schoolfriends_rp)

subgraphs = [schoolfriends_rp.subgraph(component).copy() 
for component in components]

# size of subgraphs
[len(subgraph.nodes) for subgraph in subgraphs]
```

```{python}
# view nodes in one of the smaller components
subgraphs[2].nodes
```

### Partitioning and community detection using Python

`r if (knitr::is_latex_output()) '\\index{cut (of a graph)!calculating in Python}'`
`networkx` has numerous algorithmic functions for exploring edge cuts on graphs, including to find the minimum edge cut.  You can consult the reference documentation^[https://networkx.org/documentation/stable/reference/algorithms/cuts.html] to learn about the various functions available.  Let's use the `karate` dataset to demonstrate how to find a minimum cut.  

```{python}
# get karate edgelist
karate_edges = pd.read_csv("https://ona-book.org/data/karate.csv")

# create undirected network
karate = nx.from_pandas_edgelist(karate_edges, source = "from", target = "to")

# find minimum cut
nx.minimum_edge_cut(karate)
```

```{python}
# get minimum edge cut size
len(nx.minimum_edge_cut(karate))
```

`r if (knitr::is_latex_output()) '\\index{community detection!calculating in Python}'`
Various built-in community detection algorithms are available in the `networkx.community` module, such as the `r if (knitr::is_latex_output()) '\\index{algorithm!Girvan-Newman}'`Girvan-Newman edge betweenness algorithm.  This generates communities by progressively removing edges with the highest edge betweenness centrality.  It returns an iterator object where the first element is the result of the first edge removal, and subsequent elements are the result of progressive edge removal.

```{python, wrap = TRUE}
# get communities based on girvan-newman and sort by no of communities
communities = sorted(
  nx.community.girvan_newman(karate), 
  key = len
)

# view communities from first edge removal
communities[0]
```

We see that the first split leads to two communities, one around John A and the other around Mr Hi.

The `r if (knitr::is_latex_output()) '\\index{packages!Python!cdlib@\\texttt{cdlib}}'``cdlib` package in Python contains a very wide range of community detection algorithms that work with the `networkx` package, including the Louvain and Leiden algorithms as well as many others.  In this example we create a Louvain partition of the `karate` graph using `cdlib`.

```{python, echo = FALSE}
plt.cla()
```

```{python}
from cdlib import algorithms
import numpy as np
import matplotlib.cm as cm
import matplotlib.pyplot as plt 

# get louvain partition which optimizes modularity
louvain_comms = algorithms.louvain(karate)
```

`louvain_comms` is a clustering object that has a lot of useful properties and methods.  To see the communities:

```{python, wrap = TRUE}
louvain_comms.communities
```

`r if (knitr::is_latex_output()) '\\index{modularity!calculating in Python}'`We see four communities.  The modularity of the resulting community structure can be calculated using the `newman_girvan_modularity()` method.

```{python}
louvain_comms.newman_girvan_modularity()
```

To visualize the network community structure, we can create a color mapping against the communities, as in Figure \@ref(fig:karate-py-conn).

```{python, echo = FALSE}
plt.cla()
```

```{python, eval = FALSE}
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.colors import ListedColormap, LinearSegmentedColormap

# create dict with labels only for Mr Hi and John A
node = list(karate.nodes)
labels = [i if i == "Mr Hi" or i == "John A" else "" for i in karate.nodes]
nodelabels = dict(zip(node, labels))

# create and order community mappings
communities = louvain_comms.to_node_community_map()
communities = [communities[k].pop() for k in node]

# create color map
pastel2 = cm.get_cmap('Pastel2', max(communities) + 1)

# visualize
np.random.seed(123)
nx.draw_spring(karate, labels = nodelabels, cmap = pastel2,
node_color = communities, edge_color = "grey")
plt.show()
```

```{python, echo = FALSE, results = FALSE}
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.colors import ListedColormap, LinearSegmentedColormap

# create dict with labels only for Mr Hi and John A
node = list(karate.nodes)
labels = [i if i == "Mr Hi" or i == "John A" else "" for i in karate.nodes]
nodelabels = dict(zip(node, labels))

# create and order community mappings
communities = louvain_comms.to_node_community_map()
communities = [communities[k].pop() for k in node]

# create color map
pastel2 = cm.get_cmap('Pastel2', max(communities) + 1)

# visualize
np.random.seed(123)
nx.draw_spring(karate, labels = nodelabels, cmap = pastel2,
node_color = communities, edge_color = "grey")
plt.savefig("www/segmentation/karate-py-conn.png", bbox_inches = "tight")
```

```{r karate-py-conn, echo = FALSE, fig.align="center", fig.cap="Best Louvain partition of Zachary's Karate Club graph", out.width = "90%"}
knitr::include_graphics("www/segmentation/karate-py-conn.png")
```

:::{.thinkahead data-latex=""}
**Playing around:** The options for community detection algorithms in the `cdlib` Python package are extensive.  Consider playing around with some different algorithms.  For example, you could try to visualize the community structure based on the `r if (knitr::is_latex_output()) '\\index{algorithm!Leiden}'`Leiden algorithm.  It's also worth spending a little time exploring the technical documentation for the  `cdlib` package^[https://cdlib.readthedocs.io/en/latest] to see the range of methods available.
:::

### Finding cliques in Python

`r if (knitr::is_latex_output()) '\\index{clique (in a graph)!calculating in Python}'`
`r if (knitr::is_latex_output()) '\\index{maximal clique!calculating in Python}'`
All maximal cliques in a graph can be calculated using the `find_cliques()` function:

```{python}
cliques = nx.find_cliques(karate)
maximal_cliques = sorted(cliques, key = len)

# get number of maximal cliques
len(maximal_cliques)
```

```{python}
# get largest clique
maximal_cliques[len(maximal_cliques) - 1]
```

Alternatively there are functions that can calculate the number of cliques, the size of the largest clique, and can extract the graph of the largest clique.

```{python}
nx.graph_number_of_cliques(karate)
```

```{python}
nx.graph_clique_number(karate)
```

## Examples of uses

In this section we will illustrate the implementation and interpretation of community detection algorithms using our Facebook schoolfriends example, and introducing a new example related to political tweets in the Ontario province of Canada.

### Detecting communities and cliques among Facebook friends {#schoolfriend-community}

Let's reload our `r if (knitr::is_latex_output()) '\\index{data sets!schoolfriends@\\texttt{schoolfriends}}'`Facebook school friends graph and remove any isolates so that we can investigate communities and cliques inside it.

```{r}
# get schoolfriends data
schoolfriends_edgelist <- read.csv(
  "https://ona-book.org/data/schoolfriends_edgelist.csv"
)
schoolfriends_vertices <- read.csv(
  "https://ona-book.org/data/schoolfriends_vertices.csv"
)

# facebook friendships only
schoolfriends_facebook <- schoolfriends_edgelist |> 
  dplyr::filter(type == "facebook")

# create undirected graph
schoolfriends_fb <- igraph::graph_from_data_frame(
  d = schoolfriends_facebook,
  vertices = schoolfriends_vertices,
  directed = FALSE
)

# remove isolates
isolates = which(degree(schoolfriends_fb) == 0)
schoolfriends_fb <- delete.vertices(schoolfriends_fb, isolates)
```

We now have a connected, undirected graph of 156 vertices, with class and gender as vertex properties.  First, let's detemine the largest clique in the graph.

```{r}
(cliques <- igraph::largest_cliques(schoolfriends_fb))
```

We see six cliques of 14 individuals, all of which have considerable overlap.  We can take a look at the class and gender of one of these cliques.

```{r}
# subgraph for clique 6
clique6 <- igraph::induced_subgraph(schoolfriends_fb, vids = cliques[[6]])

(data.frame(
  id = V(clique6)$name,
  class = V(clique6)$class,
  gender = V(clique6)$gender
))
```
We see that this clique is distributed over four classes and is mostly male.  Let's visualize where this clique sits in the full network as in Figure \@ref(fig:schoolfriends-clique).

```{r schoolfriends-clique, fig.align = "center", fig.cap = "Facebook schoolfriends network with one of the largest cliques indicated"}
# create clique property
V(schoolfriends_fb)$clique6 <- ifelse(
  V(schoolfriends_fb) %in% cliques[[6]], 1, 0
)

# visualize
set.seed(123)
ggraph(schoolfriends_fb, layout = "fr") +
  geom_edge_link(color = "grey", alpha = 0.7) +
  geom_node_point(size = 2, aes(color = as.factor(clique6)),
                  show.legend = FALSE) +
  theme_void()
  

```

Now let's use the `r if (knitr::is_latex_output()) '\\index{algorithm!Louvain}'`Louvain algorithm to detect communities in our graph.

```{r}
# get optimal louvain communities
communities <- igraph::cluster_louvain(schoolfriends_fb)

# assign community as a vertex property
V(schoolfriends_fb)$community <- membership(communities)

# how many communities?
length(unique(V(schoolfriends_fb)$community))
```

Six communities have been identified.  Let's compare the `r if (knitr::is_latex_output()) '\\index{modularity}'`modularity of this community structure to the known ground truth communities of class and gender.

```{r}
# modularity of louvain
modularity(schoolfriends_fb, V(schoolfriends_fb)$community)
```

```{r}
# modularity of class structure
modularity(schoolfriends_fb, as.integer(as.factor(V(schoolfriends_fb)$class)))
```

```{r}
# modularity of gender structure
modularity(schoolfriends_fb, as.integer(as.factor(V(schoolfriends_fb)$gender)))
```

This community structure is certainly a better indicator of connected Facebook subgroups than gender or class.  We can visualize the class structure side by side with the Louvain community structure to try to interpret it, as in Figure \@ref(fig:schoolfriends-louvain).

```{r schoolfriends-louvain, fig.align = "center", fig.cap = "Optimal Louvain communities in the Facebook schoolfriends graph (left) versus ground truth class communities (right)"}
# use patchwork package for combining plots easily
library(patchwork)

# visualize louvain communities
set.seed(123)
g1 <- ggraph(schoolfriends_fb, layout = "fr") +
  geom_edge_link(color = "grey", alpha = 0.7) +
  geom_node_point(size = 2, aes(color = as.factor(community)),
                  show.legend = FALSE) +
  theme_void()

# visualize ground truth class communities
set.seed(123)
g2 <- ggraph(schoolfriends_fb, layout = "fr") +
  geom_edge_link(color = "grey", alpha = 0.7) +
  geom_node_point(size = 2, aes(color = class),
                  show.legend = FALSE) +
  theme_void()

# display side by side
g1 + g2

```

Visually, we can see that the Louvain community structure is a much better representation of dense friendship groups compared to the ground truth class structure, indicating that Facebook friendships tend to span across those class structures.  We can also see that one of the Louvain communities contains the clique we identified earlier. 


### Detecting politically aligned communities on Twitter

The `r if (knitr::is_latex_output()) '\\index{data sets!ontariopol@\\texttt{ontariopol}}'``ontariopol_edgelist` and `ontariopol_vertices` data sets represent tweeting activity between Ontario province politicians in Canada as captured in September 2021 and spanning several prior years of activity.  Although the Twitter graph is a directed graph, we will set this network up as undirected, with two politicians connected if there has been an interaction between them by means of one mentioning the other in a tweet or one replying to a tweet from the other.  The `weight` property represents the number of interactions and is therefore a measure of the connection strength. 

```{r}
# get edgelist and vertex data
ontariopol_edges <- read.csv(
  "https://ona-book.org/data/ontariopol_edgelist.csv"
)
ontariopol_vertices <- read.csv(
  "https://ona-book.org/data/ontariopol_vertices.csv"
) 

# create undirected graph
(ontariopol <- igraph::graph_from_data_frame(
  d = ontariopol_edges,
  vertices = ontariopol_vertices, 
  directed = FALSE
))
```

We have an undirected, weighted graph, with `screen_name` and `party` vertex properties.  First, we check if our graph is connected:

```{r}
is.connected(ontariopol)
```

Now we use the `r if (knitr::is_latex_output()) '\\index{algorithm!Louvain}'`Louvain algorithm to detect an optimal community structure in our graph.  Since the graph has a `weight` property, our modularity calculations will include edge weight.

```{r}
# find optimal communities
communities <- igraph::cluster_louvain(ontariopol)

# assign as vertex properties
V(ontariopol)$community <- membership(communities)

# how many communities
length(unique(V(ontariopol)$community))
```

We see six commmunities.  Let's compare the `r if (knitr::is_latex_output()) '\\index{modularity}'`modularity of this community structure to the ground truth political party structure.

```{r}
# louvain modularity
modularity(ontariopol, 
           membership = V(ontariopol)$community, 
           weights = E(ontariopol)$weight)
```

```{r}
# political party modularity
modularity(ontariopol, 
           membership = as.integer(as.factor(V(ontariopol)$party)), 
           weights = E(ontariopol)$weight)
```

We see very similar modularity.  Let's visualize the Louvain community and party structure side-by-side as in Figure \@ref(fig:ontariopol-communities).

```{r ontariopol-communities, fig.align = "center", fig.cap = "Twitter interaction of Ontario politicians segmented by their Louvain communities (left) and their ground truth political parties (right).  Louvain does a good job of identifying political alignment."}
# visualize louvain communities
set.seed(123)
g1 <- ggraph(ontariopol, layout = "fr") +
  geom_edge_link(color = "grey", alpha = 0.7) +
  geom_node_point(size = 2, aes(color = as.factor(community)),
                  show.legend = FALSE) +
  theme_void()

# visualize ground truth political party communities
set.seed(123)
g2 <- ggraph(ontariopol, layout = "fr") +
  geom_edge_link(color = "grey", alpha = 0.7) +
  geom_node_point(size = 2, aes(color = party),
                  show.legend = FALSE) +
  theme_void()

# display side by side
g1 + g2
```

We see very similar community structures, indicating that the Louvain algorithm has done a good job of identifying political party alignment from the tweet activity of the politicians.  Using similar methods to our Facebook schoolfriends example in Section \@ref(schoolfriend-community), we can also identify large cliques within the political parties, as in Figure \@ref(fig:ontariopol-clique).


```{r ontariopol-clique, fig.align = "center", fig.cap = "Large Twitter clique of 48 politicians (left).  Comparison with party membership (right) reveals this to be a PCP clique."}
# get largest cliques 
cliques <- igraph::largest_cliques(ontariopol)

# there are 24 cliques of size 48 - choose one and visualize
# create clique property
V(ontariopol)$clique24 <- ifelse(
  V(ontariopol) %in% cliques[[24]], 1, 0
)

# visualize clique
set.seed(123)
g1 <- ggraph(ontariopol, layout = "fr") +
  geom_edge_link(color = "grey", alpha = 0.7) +
  geom_node_point(size = 2, aes(color = as.factor(clique24)),
                  show.legend = FALSE) +
  theme_void()

# visualize ground truth political parties
set.seed(123)
g2 <- ggraph(ontariopol, layout = "fr") +
  geom_edge_link(color = "grey", alpha = 0.5) +
  geom_node_point(size = 2, aes(color = party)) +
  labs(color = "Party (Right hand graph)") +
  theme_void()

g1 + g2
```

:::{.thinkahead data-latex=""}
**Playing around:**  In both of the examples in this section, consider extending the work to identify key important or influential nodes within communities using your learning from Chapter \@ref(vertex-importance).  Remember that the Twitter graph is a directed graph and this may impact calculations of centrality, so consider moving back to a directed graph for these calculations.  Also, try investigating what happens when you seek optimal *unweighted* Louvain communities in the `ontariopol` graph. 
:::

## Learning exercises

### Discussion questions

1. What does it mean when an undirected graph is decribed as a connected graph?  Provide similar definitions for a weakly and strongly connected directed graph.
2. By starting with a random vertex, design a set algorithmic steps that would determine all connected components of an undirected graph.
3. What is a vertex partition of a graph?  Describe how a partition arises from a series of edge cuts in a graph.
4. What is meant by a vertex clustering of a graph?
5. What is meant by a community of vertices?  What objective are we usually trying to achieve when we detect communities in a graph?
6. Describe your understanding of the term 'modularity' as it relates to community detection in graphs.
7. Name a common community detection algorithm and describe how it works.
8. What do we mean when we describe a community detection process as 'unsupervised'?
9. What is meant by the term 'clique' in an undirected graph?
10. What is a maximal clique and a largest clique in a graph?  Are maximal cliques always largest cliques?  Why or why not?

### Data exercises

For Exercises 1-3, load the `r if (knitr::is_latex_output()) '\\index{data sets!wikivote@\\texttt{wikivote}}'``wikivote` edgelist from the `onadata` package or download it from the internet^[https://ona-book.org/data/wikivote.csv].  Recall that this data set represents votes from Wikipedia members to other Wikipedia members to nominate the `to` member to administrator status.  Create a directed graph from this data set.  Be careful with trying to visualize this graph as it is large.

1. Determine how many weakly connected components there are in this graph.  How large is the largest component?
2. Determine how many strongly connected components there are in this graph.  How large is the largest component?
3. Describe how you would explain and interepret the difference between your results for Questions 1 and 2.

For exercises 4-10, load the `r if (knitr::is_latex_output()) '\\index{data sets!email@\\texttt{email}}'``email_edgelist` and `email_vertices` data sets from the `onadata` package or download them from the internet^[https://ona-book.org/daya/email_edgelist.csv and https://ona-book.org/data/email_vertices.csv].  This data set represents a network of emails sent between members of a large research institution.  The department of each member is included in the vertex data set.  Create an undirected graph from this data^[Note that the visualizations in these exercises might be demanding on low-memory/low-CPU machines. Proceed with caution.].

4. Determine the connected components of this network and reduce the network to its largest connected component.
5. Use the Louvain algorithm to determine a vertex partition/community structure with optimal modularity in this network. 
6. Compare the modularity of the Louvain community structure with that of the ground truth department structure.
7. Visualize the graph color-coded by Louvain community, and then visualize the graph separately color-coded by ground truth department.  Compare the visualizations.  Can you describe any of the Louvain communities in terms of departments?
8. Create a dataframe containing the community and department for each vertex.  Manipulate this dataframe to show the percentage of individuals from each department in each community.  Try to visalize this using a heatmap or other style of visualization and try to use this to describe the communities in terms of departments.
9.  Find the largest clique size in the graph.  How many such largest cliques are there?  What do you think a clique represents in this context?
10. Try to visualize the members of these cliques in the context of the entire graph.  What can you conclude?

**Extension:** These questions require the use of the Leiden community detection algorithm, which you may recall from earlier in this chapter is guaranteed to find a partition which at least matches the modularity of a Louvain partition, and can often improve it.  If you are a Python programmer the Leiden algorithm is easily used from the `cdlib` package.  If you are an R programmer, you will need to use the `leiden` package, which uses a Python implementation of the algorithm inside R.  You may need to be familiar with the `reticulate` package^[https://rstudio.github.io/reticulate/] to ensure that an appropriate Python environment is available inside your R session.

11. Use the Leiden community detection algorithm to find a vertex partition with optimal modularity.  How many communities does the Leiden algorithm detect?
12.  Compare the Leiden partition modularity to the Louvain partition modularity.
13.  Try to use visualization or data exploration methods to determine the main differences between the Leiden and Louvain partitions.




