
# Visualizing Graphs {#viz-graphs}

Now that we have learned how to define and store graphs, it's time to take a look at ways of visualizing them.  As we noted in earlier chapters, visualization is an important tool that can make graphs and networks real to others.  But visualizations are not always effective.  Graphs can be laid out and visualized in many different ways, and only some of them will effectively communicate the inference or conclusion that the analyst is inviting others to draw about the phenomenon being represented in the graph. 

While a graph is made up of vertices and edges, there are many other factors that will impact how the graph appears.  First, there are cosmetic matters of vertex size, edge thickness, whether or not vertices and edges are labelled, colored and so on.  Second there are matters of layout --- that is, where do we position vertices relative to each other in our visualization. As an example, recall our simple four vertex undirected graph $G_\mathrm{work}$ from Section \@ref(graph-def).  Figure \@ref(fig:two-viz-gwork) shows two different ways of visualizing this graph, where we make different choices on vertex size and on graph layout^[The right hand visualization uses the degree centrality of the vertices to scale their size --- we will learn about this later.  The layouts are also different.  The left hand visualization uses a grid layout while the right hand visualization uses a metric multidimensional scaling (MDS) layout.].  

```{r two-viz-gwork, echo = FALSE, fig.cap="Two different ways of visualizing the $G_\\mathrm{work}$ graph", fig.align ="center"}
library(igraph)
library(ggraph)
library(patchwork)

fourpeople <- data.frame(
  from = c("David", "David", "David", "Jane", "Jane"),
  to = c("Zubin", "Suraya", "Jane", "Zubin", "Suraya")
) |> 
  as.matrix()

fourpeoplegraph <- igraph::graph_from_edgelist(fourpeople)
V(fourpeoplegraph)$degree <- igraph::degree(fourpeoplegraph)

g1 <- ggraph(fourpeoplegraph, layout = "grid") +
  geom_edge_link(color = "blue") +
  geom_node_point(size = 8, color = "pink") +
  geom_node_text(aes(label = name), size = 2) +
  theme_void()

g2 <- ggraph(fourpeoplegraph, layout = "mds") +
  geom_edge_link(color = "blue") +
  geom_node_point(size = V(fourpeoplegraph)$degree*4, color = "pink") +
  geom_node_text(aes(label = name), size = 2) +
  theme_void()

g1 + g2

```

The choices of how to visualize a graph are wide and varied, and we will not be covering every single permutation and combination of cosmetics and layouts in the chapter.  Instead, we will focus on learning how to control the most common options.  This will equip the reader well not just for work we do later in this book, but also for when they need to visualize graphs they create as part of their work or study.  We will also cover a variety of graph visualization programming package options in R, Python and further afield.

In this chapter we will work with a relatively famous graph known as *Zachary's karate club*.  This graph originates from a piece of research on a karate club by a social anthropologist Wayne W. Zachary in the 1970s (@zachary), and is commonly used as an example of a social network in many teaching situations today. The graph contains 34 vertices representing different individuals or actors.  The karate instructor is labelled as 'Mr Hi'.  The club administrator is labelled as 'John A'.  The other 32 actors are labelled Actor 2 thru Actor 33.  Zachary studied the social interactions between the members outside the club meetings, and during his study a conflict arose in the club that eventually led to the group splitting into two - with one group forming a new club around the instructor Mr Hi and the other group dispersing to find new clubs or to give up karate completely.  In this graph, an edge between two vertices means that the two individuals interacted socially outside the club.


## Visualizing graphs in R 

Let's load the graph edgelist in R from the `onadata` package or from the internet^[https://ona-book.org/data/karate.csv], and check the first few rows.

```{r}
# get edgelist data as dataframe
karate_edgelist <- read.csv("https://ona-book.org/data/karate.csv")

head(karate_edgelist)

```

Now let's use our edgelist to create an undirected graph object in `igraph`.

```{r}
library(igraph)

(karate <- igraph::graph_from_data_frame(karate_edgelist, 
                                         directed = FALSE))
```

We can see that we have an undirected graph with 34 named vertices and 78 edges.  

### Native plotting in `igraph` {#native-plotting-igraph}

The `igraph` package allows simple plotting of graphs using the `plot()` function.  The function works instantly with an `igraph` object, using default values for its various arguments.  As a starting point, we will use all of the default values except for the layout of the graph.  We will set the layout of the plot initially to be a random layout, which will randomly allocate the vertices to different positions.  Figure \@ref(fig:basic-karate) shows this default plot for our `karate` network.

```{r basic-karate, fig.cap=if (knitr::is_html_output()) "Basic default plot of `karate` network" else "Basic default plot of \\texttt{karate} network", fig.align="center"}

# set seed for reproducibility
set.seed(123)

# create random layout
l <- layout_randomly(karate)

# plot with random layout
plot(karate, layout = l)
```

`r if (knitr::is_latex_output()) '<!--'`
:::thinkahead
**Thinking ahead:** The previous code chunk fixes the positioning of the vertices on our `karate` graph.  By setting a random seed, we can ensure the same random numbers are generated each time so that this plot is repeatable and reproducible.  Then the `random_layout()` function calculates random x and y coordinates for the vertices, and when we use it in the `plot()` function, it assigns those coordinates in the plot.  As we learn about layouts later in the chapter, we will use this technique a lot.  If you like, try playing around with other layouts now.  A couple of examples are `layout_with_sugiyama()` and `layout_with_dh()`.   
:::
`r if (knitr::is_latex_output()) '-->'`

`r if (knitr::is_html_output()) '<!--'`
```{=latex}
\colorbox{babyblueeyes}{
\begin{minipage}{\textwidth}
\textbf{Thinking ahead:} The previous code chunk fixes the positioning of the vertices on our \texttt{karate} graph.  By setting a random seed, we can ensure the same random numbers are generated each time so that this plot is repeatable and reproducible.  Then the \texttt{random\_layout()} function calculates random x and y coordinates for the vertices, and when we use it in the \texttt{plot()} function, it assigns those coordinates in the plot.  As we learn about layouts later in the chapter, we will use this technique a lot.  If you like, try playing around with other layouts now.  A couple of examples are \texttt{layout\_with\_sugiyama()} and \texttt{layout\_with\_dh()}.   
\end{minipage}
}
```
`r if (knitr::is_html_output()) '-->'`


Looking at Figure \@ref(fig:basic-karate), we note that the labeling of the vertices is somewhat obtrusive and unhelpful to the clarity of the graph.  This will be a common problem with default graph plotting, and with large number of vertices the plot can turn into a messy cloud of overlapping labels.

Vertex labels can be adjusted via properties of the vertices. The most common properties adjusted are as follows:

* `label`: The text of the label
* `label.family`: The font family to be used (default is 'serif')
* `label.font`: The font style, where 1 is plain (default), 2 is bold, 3 is italic, 4 is bold and italic and 5 is symbol font
* `label.cex`: The size of the label text
* `label.color`: The color of the label text
* `label.dist`: The distance of the label fron the vertex - 0 is centered on the vertex (default), 1 is beside the vertex
* `label.degree`: The angle at which the label will display relative to the center of the vertex, in radians.  The default is `-pi/4`

Let's try to change the vertex labels so that they only display for Mr Hi and for John A.  Let's also change the size, color and font family of the labels.  The output can be seen in Figure \@ref(fig:change-vlabels-karate)

```{r change-vlabels-karate, fig.cap="Adjusting label appearance through changing vertex properties", fig.align = "center"}
# only store a label if Mr Hi or John A
V(karate)$label <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"),
                          V(karate)$name,
                          "")

# change label font color, size and font family 
# (selected font family needs to be installed on system)
V(karate)$label.color <- "black"
V(karate)$label.cex <- 0.5
V(karate)$label.family <- "Lucinda Console"

plot(karate, layout = l)

```

Now that we have cleaned up the label situation, we may wish to change the appearance of the vertices.  Here are the most commonly used vertex properties which allow this:

* `size`: The size of the vertex
* `color`: The fill color of the vertex
* `frame.color`: The border color of the vertex
* `shape`: The shape of the vertex - multiple shape options are supported including `circle`, `square`, `rectangle` and `none`


We may wish to use different vertex shapes and colors for our actors compared to Mr Hi and John A.  This is how this would be done, with the results in Figure \@ref(fig:change-vertices-karate).

```{r change-vertices-karate, fig.cap="Adjusting vertex appearance through changing vertex properties", fig.align = "center"}
# different colors and shapes for Mr Hi and and John A
V(karate)$color <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"),
                          "lightblue", 
                          "pink")

V(karate)$shape <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"),
                          "square", 
                          "circle")


plot(karate, layout = l)
```

In a similar way, edges can be changed through adding or editing edge properties.  Here are some common edge properties that are used to change the edges in an `igraph` plot:

* `color`: The color of the edge
* `width`: The width of the edge
* `arrow.size`: The size of the arrow in a directed edge
* `arrow.width`: The width of the arrow in a directed edge
* `arrow.mode`: Whether edges should direct forward (`>`), backward (`<`) or both (`<>`)
* `lty`: Line type of edges, with numerous options including `solid`, `dashed`, `dotted`, `dotdash` and `blank`
* `curved`: Specifies the amount of curvature to apply to the edge, with zero (default) as a straight edge, negative numbers bending clockwise and positive bending anti-clockwise

Note that edges, like vertices, can also have `label` a label property and various label settings like `label.cex` and `label.family`.  Let's adjust our `karate` graph to have blue dashed edges, with the result in \@ref(fig:change-edges-karate).

```{r change-edges-karate, fig.cap="Adjusting edge appearance through changing edge properties", fig.align = "center"}
# change color and linetype of all edges
E(karate)$color <- "blue"
E(karate)$lty <- "dashed"

plot(karate, layout = l)
```

`r if (knitr::is_latex_output()) '<!--'`
:::thinkahead
**Playing around:** Usually, getting your graph looking the way you want take some trial and error and some playing around with its properties.  Try further adjusting the `karate` graph using some of the other properties listed.    
:::
`r if (knitr::is_latex_output()) '-->'`

`r if (knitr::is_html_output()) '<!--'`
```{=latex}
\colorbox{babyblueeyes}{
\begin{minipage}{\textwidth}
\textbf{Thinking ahead:} Usually, getting your graph looking the way you want take some trial and error and some playing around with its properties.  Try further adjusting the \texttt{karate} graph using some of the other properties listed. 
\end{minipage}
}
```
`r if (knitr::is_html_output()) '-->'`



### Graph layouts {#layouts}

The layout of a graph determines the precise position of its vertices on a 2-dimensional plane or in 3-dimensional space.  Layouts are themselves algorithms that calculate vertex positions based on properties of the graph.  Different layouts work for different purposes, for example to visually identify communities in a graph, or just to make the graph look pleasant.  In Section \@ref(native-plotting-igraph), we used a random layout for our `karate` graph.  Now let's look at common alternative layouts. Layouts are used by multiple plotting packages, but we will explore them using `igraph` base plotting capabilities here.

There are two ways to add a layout to a graph in `igraph`.  If you want to keep the graph object separate from the layout, you can create the layout and use it as an argument in the `plot()` function, like we did for Figure \@ref(fig:basic-karate).  Alternatively, you can assign a layout to a graph object by making it a property of the graph.  You should only do this if you intend to stick permanently with your chosen layout and do not intend to experiment.  You can use the `add_layout_()` function to achieve this.  For example, this would create a `karate` graph with a grid layout. 

```{r}
# check whether existing karate graph has a layout property
karate$layout
```

```{r}
# assign grid layout as a graph property
set.seed(123)
karate_grid <- igraph::add_layout_(karate, on_grid())

# check a few lines of the 'layout' property
head(karate_grid$layout)
```

We can see that our new graph object has a layout property.  Note that running `add_layout_()` on a graph that already has a layout property will by default overwrite the previous layout unless you set the argument `overwrite = FALSE`.

As well as the random layout demonstrated in Figure \@ref(fig:basic-karate), common shape layouts include `as_star()`,  `as_tree()`, `in_circle()`, `on_grid()` and `on_sphere()`.  For example, Figure \@ref(fig:circle-karate) shows the circle layout for our `karate` network, and Figure \@ref(fig:sphere-karate) shows the sphere layout.

```{r circle-karate, fig.cap=if (knitr::is_html_output()) "Circle layout of the `karate` graph" else "Circle layout of the \\texttt{karate} graph", fig.align = "center"}
# circle layout
set.seed(123)
circ <- layout_in_circle(karate)
plot(karate, layout = circ)
```

```{r sphere-karate, fig.cap=if (knitr::is_html_output()) "Sphere layout of the `karate` graph" else "Sphere layout of the \\texttt{karate} graph", fig.align = "center"}
# sphere layout
set.seed(123)
sph <- layout_on_sphere(karate)
plot(karate, layout = sph)
```

`r if (knitr::is_latex_output()) '<!--'`
:::thinkahead
**Thinking ahead:** Notice how the circle and sphere layouts position Mr Hi and John A very close to each other.  This is an indication that the layout algorithms have established something in common between these two individuals based on the properties of the graph.  This is something we will cover in a later chapter, but if you want to explore ahead, and you know how to, calculate some centrality measures for the vertices in the `karate` graph --- for example degree centrality and betweenness centrality. 
:::
`r if (knitr::is_latex_output()) '-->'`

`r if (knitr::is_html_output()) '<!--'`
```{=latex}
\colorbox{babyblueeyes}{
\begin{minipage}{\textwidth}
\textbf{Thinking ahead:} Notice how the circle and sphere layouts position Mr Hi and John A very close to each other.  This is an indication that the layout algorithms have established something in common between these two individuals based on the properties of the graph.  This is something we will cover in a later chapter, but if you want to explore ahead, and you know how to, calculate some centrality measures for the vertices in the \texttt{karate} graph --- for example degree centrality and betweenness centrality. 
\end{minipage}
}
```
`r if (knitr::is_html_output()) '-->'`


*Force-directed* graph layouts are extremely popular, as they are aesthetically pleasing and they help visualize communities of vertices quite effectively, especially in graphs with low to moderate edge-complexity.  These algorithms emulate physical models like Hooke's law to attract connected vertices together, while at the same time applying repelling forces to all pairs of vertices to try to keep as much space as possible between them.  This calculation is an iterative process where vertex positions are recalculated again and again until equilibrium is reached^[Note that this means that the process is usuallu highly computationally expensive on large graphs and can easily freeze up your machine if you are not careful.].  The result is is usually a layout where connected vertices are closer together and where edge-length are approximately equal.  

For Zachary's Karate Club study, which was a study of connection and community, we can imagine that a force-directed layout would be a good choice of visualization, and we will find that this is the case for many other network graphs we study.  There are several different implementations of force directed algorithms available.  Perhaps the most popular of these is the Fruchterman-Reingold algorithm.  Figure \@ref(fig:fr-karate) shows our `karate` network with the layout generated by the Fruchterman-Reingold algorithm, and we can see clear communities in the karate club oriented around Mr Hi and John A..

```{r fr-karate, fig.cap=if (knitr::is_html_output()) "Force-directed layout of the `karate` graph according to the Fruchterman-Reingold algorithm" else "Force-directed layout of the \\texttt{karate} graph according to the Fruchterman-Reingold algorithm", fig.align = "center"}
# F-R algorithm
set.seed(123)
fr <- layout_with_fr(karate)
plot(karate, layout = fr)
```

The Kamada-Kawai algorithm and the GEM algorithm are also commonly used force-directed algorithms and they produce similar types of community structures as in Figures \@ref(fig:kk-karate) and \@ref(fig:gem-karate) respectively.

```{r kk-karate, fig.cap=if (knitr::is_html_output()) "Force-directed layout of the `karate` graph according to the Kamada-Kawai algorithm" else "Force-directed layout of the \\texttt{karate} graph according to the Kamada-Kawai algorithm", fig.align = "center"}
## K-K algorithm
set.seed(123)
kk <- layout_with_kk(karate)
plot(karate, layout = kk)
```

```{r gem-karate, fig.cap=if (knitr::is_html_output()) "Force-directed layout of the `karate` graph according to the GEM algorithm" else "Force-directed layout of the \\texttt{karate} graph according to the GEM algorithm", fig.align = "center"}
## GEM algorithm
set.seed(123)
gem <- layout_with_gem(karate)
plot(karate, layout = gem)
```

As well as force-directed and shape=oriented layout algorithms, several alternative approaches to layout calculation are also available.  `layout_with_dh()` uses a simulated annealing algorithm developed for nice graph drawing, and `layout_with_mds()` generates vertex coordinates through multi-dimensional scaling based on shortest path distance (which we will look at in a later chapter).  `layout_with sugiyama()` is suitable for directed graphs and minimizes edge crossings by introducing bends on edges --- the multigraph visualization in Figure \@ref(fig:gmulti) was generated using the Sugiyama layout algorithm.

Finally, there are three layout algorithms that are suited for large graphs with many thousands or even millions of edges. One of the biggest problems with visualizing large graphs is the potential for 'hairballs' --- that is, clumps of connected nodes that are so dense they cannot be usefully visualized.  `layout_with_lgl()` uses the Large Graph Layout algorithm which tries to identify clusters of vertices and position the clusters before positioning the individual vertices to minimize the chance of hairballs, while still adhering to the principles of force-directed networks. `layout_with_drl()` and  `layout_with_graphopt()` uses efficient force-directed algorithms which scale well on large graphs.  

`r if (knitr::is_latex_output()) '<!--'`
:::thinkahead
**Playing around:** Try laying out the `karate` graph using these various algorithms and observe the different appearances.  If you are interested in experimenting with a larger graph, and you have enough computing power that it won't freeze your machine, load the `wikivote` edgelist from the `onadata` package, or download it from the internet^[https://ona-book.org/data/wikivote.csv.  This data set is taken from the Stanford University SNAP library of network data sets]. This network represents votes from Wikipedia members for other members to be made administrators.  Create a directed graph object, and lay it out using `layout_with_graphopt()`.  To help with your visualization, remove the vertex labels, set the node size to 0.5 and set the edge arrow size to 0.1. When you plot this, you should see a great example of a hairball, as in Figure \@ref(fig:hairball-example).   
:::
`r if (knitr::is_latex_output()) '-->'`

`r if (knitr::is_html_output()) '<!--'`
```{=latex}
\colorbox{babyblueeyes}{
\begin{minipage}{\textwidth}
\textbf{Playing around:} Try laying out the \texttt{karate} graph using these various algorithms and observe the different appearances.  If you are interested in experimenting with a larger graph, and you have enough computing power that it won't freeze your machine, load the \texttt{wikivote} edgelist from the \texttt{onadata} package, or download it from the internet at \texttt{https://ona-book.org/data/wikivote.csv}.  This data set is taken from the Stanford University SNAP library of network data sets. It represents votes from Wikipedia members for other members to be made administrators.  Create a directed graph object, and lay it out using \texttt{layout\_with\_graphopt()}.  To help with your visualization, remove the vertex labels, set the node size to 0.5 and set the edge arrow size to 0.1. When you plot this, you should see a great example of a hairball, as in Figure \ref{fig:hairball-example}.  
\end{minipage}
}
```
`r if (knitr::is_html_output()) '-->'`

```{r hairball-example, echo = FALSE, fig.cap="Example of a hairball generated by trying to visualize a large network of Wikipedia votes for administrators", fig.align = "center", width.out = "80%"}
knitr::include_graphics("www/visualizing-graphs/hairball.png")
```

In the absence of any information on layout, the `plot()` function in `igraph` will choose an appropriate layout using a logic determined by `layout_nicely()`.  If the graph already has a `layout` attribute, it will use this layout.  Otherwise, if the vertices have `x` and `y` attributes, it will use these as vertex co-ordinates.  Failing both of these, `layout_with_fr()` will be used if the graph has fewer than 1,000 vertices, and `layout_with_drl()` will be used if the graph has more than 1,000 vertices.  Thus, the plot defaults to a form of force-directed layout unless the graph attributes suggest otherwise.  

### Plotting with `ggraph`

The `ggraph` package is developed for those who enjoy working with the more general `ggplot2` package, which is a very popular plotting package in R.  To learn `ggplot2` as a foundational package, @ggplot2 is highly recommended.  As with `ggplot2`, `ggraph` provides a grammar for building graph visualizations.  While the native capabilities of `igraph` will suffice in R for most static graph visualizations, `ggraph` could be considered an additional option for those who prefer to use it.  It also integrates well with `ggplot2` which allows further layers to be added to the graph visualization, such as a greater variety of node shapes and the ability to layer networks onto geographic maps with relative ease --- we will look at a nice example of this later in this section.

To build an elementary graph using `ggraph`, we start with an `igraph` object and a layout, and we then progressively add node and edge properties as well as themes and other layer if required.  To illustrate, let's generate a relatively basic visualization of our `karate` graph using `ggraph` as in Figure \@ref(fig:ggraph-basic-karate).  Note that its is customary to add the edges before the nodes so that the nodes are the top layer in the plot.

```{r ggraph-basic-karate, fig.align = "center", fig.cap=if (knitr::is_html_output()) {"Elementary visualization of `karate` graph using `ggraph` and the Fruchterman-Reingold algorithm"} else {"Elementary visualization of \\texttt{karate} graph using \\texttt{ggraph} and the Fruchterman-Reingold algorithm"}}
library(igraph)
library(ggraph)

# get karate edgelist
karate_edgelist <- read.csv("https://ona-book.org/data/karate.csv")

# create graph object
karate <- igraph::graph_from_data_frame(karate_edgelist, directed = FALSE)

# set seed for reproducibility
set.seed(123)

# visualise using ggraph with fr layout
ggraph(karate, layout = "fr") +
  geom_edge_link() +
  geom_node_point() 
  

```

This is not particularly appealing.  However, we can play with properties to improve the appearance, and we can move to a minimal theme to remove the grey background and add a title if we wish, as in Figure \@ref(fig:ggraph-nicer-karate).

```{r ggraph-nicer-karate, fig.align = "center", fig.cap=if (knitr::is_html_output()) {"Improved visualization of `karate` graph using node and edge properties"} else {"Elementary visualization of \\texttt{karate} graph using node and edge properties"}}
set.seed(123)
ggraph(karate, layout = "fr") +
   geom_edge_link(color = "grey", alpha = 0.5) + 
  geom_node_point(color = "blue", size = 5) +
  theme_void() + 
  labs(title = "Zachary's Karate Club Network")
```

Like in `ggplot2`, if we want to associate a property of the nodes or edges with a property of the plot, we can use aesthetic mappings.  For example, let's give Mr Hi and John A the property of "leader" in our graph, and then ask `ggraph` to color the nodes by this property, as in Figure \@ref(fig:ggraph-leader-karate).

```{r ggraph-leader-karate, fig.align = "center", fig.cap=if (knitr::is_html_output()) {"`karate` graph with `leader` property used as an aesthetic"} else {"\\texttt{karate} graph with \\texttt{leader} property used as an aesthetic"}}

V(karate)$leader <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"), 1, 0)

set.seed(123)
ggraph(karate, layout = "fr") +
  geom_edge_link(color = "grey", alpha = 0.5) + 
  geom_node_point(aes(color = as.factor(leader)), size = 5, show.legend = FALSE) +
  theme_void() + 
  labs(title = "Zachary's Karate Club Network")
```

As a further example of using `ggraph`, let's look at a dataset collected during a study of workplace interactions in France in 2015 (@Genois2018).  Load the `workfrance_edgelist` and `workfrance_vertices` data sets from the `onadata` package or download them from the internet^[https://ona-book.org/data/workfrance_edgelist.csv and https://ona-book.org/data/workfrance_vertices.csv].  In this study, employees of a company wore wearable devices to triangulate their location in the building, and edges were defined as any situation where two employees were sharing the same spatial location.  The edgelist contains `from` and `to` columns for the edges, as well as a `mins` column representing the total minutes spent co-located during the study^[This data set has been further processed from the original data set, including limiting the edges to those where the total mco-location time was at least 5 minutes.].  The vertex list contains data on the department of each employee ID.  We will create a basic visualization of this using `ggraph` in Figure \@ref(fig:workfrance-basic).

```{r workfrance-basic, fig.align = "center", fig.cap="Connection of employees in a workplace as measured by spatial co-location"}

# get edgelist with mins property
workfrance_edgelist <- read.csv("https://ona-book.org/data/workfrance_edgelist.csv")

# get vertex set with dept property
workfrance_vertices <- read.csv("https://ona-book.org/data/workfrance_vertices.csv")

# create undirected graph object
workfrance <- igraph::graph_from_data_frame(
  d = workfrance_edgelist,
  vertices = workfrance_vertices,
  directed = FALSE
)

# basic visualization
set.seed(123)
ggraph(workfrance, layout = "fr") +
  geom_edge_link(color = "gray", alpha = 0.2) +
  geom_node_point(color = "blue", size = 5) +
  theme_void()
```

As it stands, this graph does not tell us much, but a couple of simple adjustments can change this.  First, we can adjust the thickness of the edges to reflect the total number of minutes spent meeting, which seems a reasonable measure of the 'strength' or 'weight' of the connection.  Second, we can color code the nodes by their department.  The result is Figure \@ref(fig:workfrance-additional).  We can now see clusters of highly connected employees mostly driven by their department. 

```{r workfrance-additional, fig.align = "center", fig.cap="Connection of employees in a workplace with edge thickness weighted by minutes spent spatially co-located and vertices colored by department"}
set.seed(123)
ggraph(workfrance, layout = "fr") +
  geom_edge_link(color = "gray", alpha = 0.2, aes(width = mins), 
                 show.legend = FALSE) +
  geom_node_point(aes(color = dept), size = 5) +
  theme_void() +
  labs(title = "Spatial co-location of employees in a workplace")
```

`r if (knitr::is_latex_output()) '<!--'`
:::thinkahead
**Thinking ahead:** The graph we have just created in Figure \@ref(fig:workfrance-additional) shows how we have detected a community segmentation of our vertices.  It's relatively clear that individuals in the same department are more likely to be connected.  Community segmentation is an important topic in Organizational Network Analysis which we will study later in this book.  It's not always straightforward to identify drivers of community in networks, but we will learn about a number of community detection algorithms which will segment the graph into different community groups.  As an example, Figure \@ref(fig:workfrance-louvain) shows the results of running the Louvain community detection algorithm on the `workfrance` graph with `mins` as the edge weights.  You can see that the communities detected are strongly alignd with the departments in Figure \@ref(fig:workfrance-additional).    
:::
`r if (knitr::is_latex_output()) '-->'`

`r if (knitr::is_html_output()) '<!--'`
```{=latex}
\colorbox{babyblueeyes}{
\begin{minipage}{\textwidth}
\textbf{Thinking ahead:} The graph we have just created in Figure \ref{fig:workfrance-additional} shows how we have detected a community segmentation of our vertices.  It's relatively clear that individuals in the same department are more likely to be connected.  Community segmentation is an important topic in Organizational Network Analysis which we will study later in this book.  It's not always straightforward to identify drivers of community in networks, but we will learn about a number of community detection algorithms which will segment the graph into different community groups.  As an example, Figure \ref{fig:workfrance-louvain} shows the results of running the Louvain community detection algorithm on the \texttt{workfrance} graph with \texttt{mins} as the edge weights.  You can see that the communities detected are strongly alignd with the departments in Figure \ref{fig:workfrance-additional}.   
\end{minipage}
}
```
`r if (knitr::is_html_output()) '-->'`

```{r workfrance-louvain, echo = FALSE, fig.align = "center", fig.cap="Clusters of employees as detected by the Louvain community detection algorithm.  Note the cluster similarity of communities with the departments in the previous graph."}
louv <- igraph::cluster_louvain(workfrance, weights = E(workfrance)$mins)
V(workfrance)$community <- louv$membership

set.seed(123)
ggraph(workfrance, layout = "fr") +
  geom_edge_link(color = "gray", alpha = 0.2, aes(width = mins), 
                 show.legend = FALSE) +
  geom_node_point(aes(color = as.factor(community)), size = 5) +
  theme_void() +
  labs(
    color = "Community",
    title = "Communities detected by the Louvain algorithm"
  )
```


`ggraph` visualizations can work relatively easily with other graphics layers, allowing you to superimpose a graph onto other co-ordinate systems.  Let's look at an example of this at work.  Load the `londontube_edgelist` and `londontube_vertices` data sets from the `onadata` package or download them from the internet^[https://ona-book.org/data/londontube_edgelist.csv and https://ona-book.org/data/londontube_vertices.csv].  The vertex set is a list of London Tube Stations with an `id`, `name` and geographical co-ordinates `longitude` and `latitude`.

```{r}
# download and view london tube vertex data
londontube_vertices <- read.csv("https://ona-book.org/data/londontube_vertices.csv")
head(londontube_vertices)
```
The edge list represents `from` and `to` connections between stations, along with the name of the `line` and its official `linecolor` in hex code.

```{r}
# download and view london tube edge data
londontube_edgelist <- read.csv("https://ona-book.org/data/londontube_edgelist.csv")
head(londontube_edgelist)
```

We can easily create am `igraph` object from this data and then use `ggraph` to create a visualization using the `linecolor` as the edge color between stations, as in Figure \@ref(fig:non-geo-tube).

```{r non-geo-tube, fig.align = "center", fig.cap = "Random graph visualization of the London Tube network graph with the edges colored by the different lines"}
# create a set of distinct line names and lincolors to use
lines <- londontube_edgelist |> 
  dplyr::distinct(line, linecolor)

# create graph object
tubegraph <- igraph::graph_from_data_frame(d = londontube_edgelist, 
                                           vertices = londontube_vertices,
                                           directed = FALSE)

# visualize tube graph using linecolors for edge color
set.seed(123)
ggraph(tubegraph) +
  geom_node_point(color = "black", size = 1) +
  geom_edge_link(aes(color = line), width = 1) +
  scale_edge_color_manual(name = "Line",
                          values = lines$linecolor) +
  theme_void()
```

While it's great that we can do this so easily, it's a pretty confusing visualization for anyone who knows London.  The Circle Line doesn't look very circular, the Picadilly Line seems to he heading southeast instead of northeast.  In the west, the Metropolitan and Picadilly Lines seem to have swapped places.  Of course, this graph is not using geographical co-ordinates to plot its vertices.  

We can change this by expanding our edgelist to include the latitudes and longitudes of the `from` and `to` stations in each edge, and then we can layer a map on this graph.  First, let's create those new longitude and latitude columns in the edgelist, and check it works.

```{r}
# we reorganize the edgelist to include longitude and latitude for start and end
new_edgelist <- londontube_edgelist |> 
  dplyr::inner_join(londontube_vertices |> 
                      dplyr::select(id, latitude, longitude), 
                    by = c("from" = "id")) |> 
  dplyr::rename(lat_from = latitude, lon_from = longitude) |> 
  dplyr::inner_join(londontube_vertices |> 
                      dplyr::select(id, latitude, longitude), 
                    by = c("to" = "id")) |> 
  dplyr::rename(lat_to = latitude, lon_to = longitude)

# view
head(new_edgelist)

```
That looks like it worked.  Now we can use the `ggmap` package in R to layer a map of London on top of the base `ggraph` layer, and then use the various latitude and longitude columns to make our network geographically accurate, as in Figure \@ref(fig:geo-accurate-tube)^[A Google Maps API key is needed to use `ggmap` - see https://github.com/dkahle/ggmap for more information.].

```{r geo-accurate-tube, fig.align = "center", fig.cap = "Geographically accurate London Tube Network"}
# recreate graph object to capture additional edge data
tubegraph <- igraph::graph_from_data_frame(d = new_edgelist, 
                                           vertices = londontube_vertices,
                                           directed = FALSE)

# layer a London map
library(ggmap)
londonmap <- get_map(location = "London, UK", source = "google")

ggmap(londonmap, base_layer = ggraph(tubegraph)) +
  geom_node_point(aes(x = longitude, y = latitude), color = "black", size = 1) +
  geom_edge_link(aes(x = lon_from, y = lat_from,
                     xend = lon_to, yend = lat_to,
                     color = line), width = 1) +
  scale_edge_color_manual(name = "Line",
                          values = lines$linecolor)
```

Figure \@ref(fig:geo-accurate-tube) looks like the everything is in the right place.  This kind of graphical layering can be extremely important when there is an inherent co-ordinate system lying behind the vertices of your graph and where none of the existing layout algorithms can recreate that co-ordinate system.

### Interactive graph visualization in R

We have seen earlier how many large networks are too complicated to make sense of visually using static approaches such as the methods we have already reviewed in `igraph` or `ggraph`.  Nevertheless, interactive visualizations of networks can be useful where there is an interest in visual exploration of particular vertices or small sub-networks, even when the overall network is visually complex.  We will touch upon a couple of commonly used interactive graph visualization packages here, all of which use Javascript libraries behind the scenes to create the interactive visualizations.

`visNetwork` is a simple but effective package which uses `vis.js` API create HTML widgets containing interactive graph visualizations.  It is fairly easily to use, with its main function `visNetwork()` taking a dataframe of node information and a dataframe of edge information, as well as a few other optional arguments.  The columns in these dataframes are expected to have certain default column names.  Vertices/nodes are expected to at least have an `id` column but can also contain:

* `label`: the label of the vertex
* `group`: the group of the vertex if there are groups
* `value`: used to determine the size of the vertex
* `title`:  This will be used as a tooltip on mouseover
* other columns can be included to be passed to specific values/properties in the visualization, such as `color` or `shape`.

The edge dataframe must contain a `from` and `to` column, and can also contain `label`, `value` and `title` to customize the edges as with the vertices, as well as other properties such as `arrows` or `dashes`.

`r if (knitr::is_html_output()) {"Interactive"}` Figure \@ref(fig:gwork-visnetwork) is a very simple `r if (knitr::is_latex_output()) {"statically rendered"}` example of the `visNetwork` function at work using our $G_\mathrm{work}$ graph from Section \@ref(graph-def).  Note that the `visLayout()` function can be used for various customizations, including passing a random seed variable to `vis.js` to ensure the same result.

```{r, eval = FALSE}
library(visNetwork)

nodes <- data.frame(
id = 1:4,
label = c("David", "Zubin", "Suraya", "Jane")
)

edges <- data.frame(
  from = c(1, 1, 1, 4, 4),
  to = c(2, 3, 4, 2, 3)
)

visNetwork(nodes, edges) |> 
  visLayout(randomSeed = 123)


```


```{r gwork-visnetwork, echo = FALSE, fig.align = "center", fig.cap = if (knitr::is_html_output()) {"Simple `visNetwork` rendering of the $G_\\mathrm{work}$ graph"} else {"Simple \\texttt{visNetwork} rendering of the $G_\\mathrm{work}$ graph"}, out.width = if (knitr::is_latex_output()) "80%"}
library(visNetwork)

if (knitr::is_html_output()) {
  nodes <- data.frame(
    id = 1:4,
    label = c("David", "Zubin", "Suraya", "Jane")
  )

  edges <- data.frame(
    from = c(1, 1, 1, 4, 4),
    to = c(2, 3, 4, 2, 3)
  )

  visNetwork::visNetwork(nodes, edges) |> 
    visLayout(randomSeed = 123)
} else {
  knitr::include_graphics("www/visualizing-graphs/gwork-visnetwork.png")
}



```


In fact, assuming that we are working with `igraph` objects, the easiest way to deploy `visNetwork` is to use the `visIgraph()` function, which takes an `igraph` object and restructures it behind the scenes to use the `vis.js` API, even inheriting whatever `igraph` layout you prefer.  Let's recreate our `karate` graph in `visNetwork`, as in `r if (knitr::is_html_output()) {"Interactive"}` Figure \@ref(fig:karate-visnetwork).

```{r, eval = FALSE}
library(igraph)
library(ggraph)

# get karate edgelist
karate_edgelist <- read.csv("https://ona-book.org/data/karate.csv")

# create graph object
karate <- igraph::graph_from_data_frame(karate_edgelist, directed = FALSE)

# different colors and shapes for Mr Hi and and John A
V(karate)$color <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"),
                          "lightblue", 
                          "pink")

V(karate)$shape <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"),
                          "square", 
                          "circle")

# visualize from igraph
visNetwork::visIgraph(karate, layout = "layout_with_fr") |> 
  visLayout(randomSeed = 123)
```



```{r karate-visnetwork, echo = FALSE, fig.align = "center", fig.cap = if (knitr::is_html_output()) {"`visNetwork` rendering of the basic `karate` graph using a force-directed layout"} else {"\\texttt{visNetwork} rendering of the basic Karate graph using a force-directed layout"}, out.width = if (knitr::is_latex_output()) "80%"}

if (knitr::is_html_output()) {
  library(igraph)
  library(ggraph)
  
  # get karate edgelist
  karate_edgelist <- read.csv("https://ona-book.org/data/karate.csv")
  
  # create graph object
  karate <- igraph::graph_from_data_frame(karate_edgelist, directed = FALSE)
  
  # different colors and shapes for Mr Hi and and John A
  V(karate)$color <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"),
                            "lightblue", 
                            "pink")
  
  V(karate)$shape <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"),
                            "square", 
                            "circle")

# visualize from igraph
visNetwork::visIgraph(karate, layout = "layout_with_fr") |> 
  visLayout(randomSeed = 123)
} else {
  knitr::include_graphics("www/visualizing-graphs/karate-visnetwork.png")
}

```

`r if (knitr::is_latex_output()) '<!--'`
:::thinkahead
**Playing around:** The `visNetwork` package allows you to take advantage of a ton of features in the `vis.js` API, including a wide range of graph customization, and the ability to make your graph editable or to add selector menu to search for specific nodes or groups of nodes.  It's worth experimenting with all the different capabilities.  A thorough manual can be found at [https://datastorm-open.github.io/visNetwork/](https://datastorm-open.github.io/visNetwork/).  Why don't you try to recreate the `workfrance` graph from this chapter in `visNetwork`?
:::
`r if (knitr::is_latex_output()) '-->'`

`r if (knitr::is_html_output()) '<!--'`
```{=latex}
\colorbox{babyblueeyes}{
\begin{minipage}{\textwidth}
\textbf{Playing around:} The \texttt{visNetwork} package allows you to take advantage of a ton of features in the \texttt{vis.js} API, including a wide range of graph customization, and the ability to make your graph editable or to add selector menu to search for specific nodes or groups of nodes.  It's worth experimenting with all the different capabilities.  A thorough manual can be found at \texttt{https://datastorm-open.github.io/visNetwork/}.  Why don't you try to recreate the \texttt{workfrance} graph from this chapter in \texttt{visNetwork}?
\end{minipage}
}
```
`r if (knitr::is_html_output()) '-->'`

The `networkD3` package creates responsive and interactive network visualizations using the `D3` javascript library, which has some beautiful options for common network layouts like force-directed or chord diagrams.

To create a simple force-directed visualization based on an edgelist, use the `simpleNetwork()` function.  All this needs is simple dataframe where by default the first two columns represent the edgelist^[You can use the arguments in the `simpleNetwork()` function to define the Source and Target columns if they are not the first two columns].  Here is an example for the `karate` network, with `r if (knitr::is_latex_output()) {"a static image of"}` the result shown in `r if (knitr::is_html_output()) {"Interactive"}` Figure \@ref(fig:simple-networkD3).  Note that it is not possible to set a random seed with `networkD3`.

```{r, eval = FALSE}
library(networkD3)

# get karate edgelist
karate_edgelist <- read.csv("https://ona-book.org/data/karate.csv")
  
# visualize
networkD3::simpleNetwork(karate_edgelist)
  
```

```{r simple-networkD3, echo = FALSE, fig.align = "center", fig.cap = if (knitr::is_html_output()) {"Simple `networkD3` rendering of the Karate graph"} else {"Simple \\texttt{networkD3} rendering of the Karate graph"}, out.width = if (knitr::is_latex_output()) "80%"}
library(networkD3)

if (knitr::is_html_output()) {
  # get karate edgelist
  karate_edgelist <- read.csv("https://ona-book.org/data/karate.csv")
  
  # visualize
  networkD3::simpleNetwork(karate_edgelist)
  
  
} else {
  knitr::include_graphics("www/visualizing-graphs/simple-networkD3.png")
}
```


The `forceNetwork()` function allows greater levels of customization of the visualization.  This function requires an edgelist and a vertex set in a specific format.  However, we can use the function `igraph_to_networkD3()` to easily create a list containing what we need from an `igraph` object. In the next example, we recreate the graph in Figure \@ref(fig:simple-networkD3) but we put Mr Hi and John A into a different group, with `r if (knitr::is_latex_output()) {"a static image of"}` the result shown in `r if (knitr::is_html_output()) {"Interactive"}` Figure \@ref(fig:force-networkD3).  Note that node names only appear when nodes are clicked.

```{r, eval = FALSE}
# get karate edgelist
karate_edgelist <- read.csv("https://ona-book.org/data/karate.csv")

# create igraph object
karate <- igraph::graph_from_data_frame(karate_edgelist, directed = FALSE)

# give Mr Hi and John A a different group
V(karate)$group <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"), 1, 2)

# translate to networkD3 - creates a list with links and nodes dfs
# links have a source and target column and group if requested 
netd3_list <- networkD3::igraph_to_networkD3(karate, 
                                             group = V(karate)$group)

# visualize
networkD3::forceNetwork(
  Links = netd3_list$links,
  Nodes = netd3_list$nodes,
  NodeID = "name",
  Source = "source",
  Target = "target",
  Group = "group"
)
```

```{r force-networkD3, echo = FALSE, fig.align = "center", fig.cap = if (knitr::is_html_output()) {"Force-directed `networkD3` rendering of the Karate graph"} else {"Force-directed \\texttt{networkD3} rendering of the Karate graph"}, out.width = if (knitr::is_latex_output()) "80%"}
if (knitr::is_html_output()) {
  # get karate edgelist
  karate_edgelist <- read.csv("https://ona-book.org/data/karate.csv")
  
  # create igraph object
  karate <- igraph::graph_from_data_frame(karate_edgelist, directed = FALSE)
  
  # give Mr Hi and John A a different group
  V(karate)$group <- ifelse(V(karate)$name %in% c("Mr Hi", "John A"), 1, 2)
  
  # translate to networkD3 - creates a list with links and nodes dfs
  # links have a source and target column and group if requested 
  netd3_list <- networkD3::igraph_to_networkD3(karate, 
                                               group = V(karate)$group)
  
  # visualize
  networkD3::forceNetwork(
    Links = netd3_list$links,
    Nodes = netd3_list$nodes,
    NodeID = "name",
    Source = "source",
    Target = "target",
    Group = "group"
  )
  
  
} else {
  knitr::include_graphics("www/visualizing-graphs/force-networkD3.png")
}
```

Other types of `D3` network visualizations are also available  such as `chordNetwork()`, and `sankeyNetwork()`, with many of these more appropriate for data visualization purposes than for the exploration and analysis of networks.  As a quick example of using `sankeyNetwork()` to visualize data flows, load the `eu_referendum` dataset from the `onadata` package or download it from the internet^[https://ona-book.org/data/eu_referendum.csv].  This shows statistics on voting by region and area in the United Kingdom's 2017 referendum on membership of the European Union.  In this example, we will calculate the Leave and Remain votes by region and visualize them using `sankeyNetwork()`, with `r if (knitr::is_latex_output()) {"a static image of"}` the result shown in `r if (knitr::is_html_output()) {"Interactive"}` Figure \@ref(fig:eu-sankey). It is worth taking a look at the intermediate objects created by this code so you can better understand how to construct the `Nodes` and `Links` dataframes that are commonly expected by `networkD3` functions. 

```{r, eval = FALSE}
library(dplyr)
library(networkD3)
library(tidyr)

# get data
eu_referendum <- read.csv("https://ona-book.org/data/eu_referendum.csv")

# aggregate by region
results <- eu_referendum |>  
  dplyr::group_by(Region) |> 
  dplyr::summarise(Remain = sum(Remain), Leave = sum(Leave)) |> 
  tidyr::pivot_longer( -Region, names_to = "result", values_to = "votes")

# create unique regions, "Leave" and "Remain" for nodes dataframe
regions <- unique(results$Region)
nodes <- data.frame(node = c(0:13), 
                  name = c(regions, "Leave", "Remain"))

#create edges/links dataframe
results <- results |> 
  dplyr::inner_join(nodes, by = c("Region" = "name")) |> 
  dplyr::inner_join(nodes, by = c("result" = "name"))

links <- results[ , c("node.x", "node.y", "votes")]
colnames(links) <- c("source", "target", "value")

# visualize using sankeyNetwork
networkD3::sankeyNetwork(
  Links = links, Nodes = nodes, Source = 'source', Target = 'target', 
  Value = 'value', NodeID = 'name', units = 'votes'
)
```


```{r eu-sankey, echo = FALSE, fig.align = "center", fig.cap = if (knitr::is_html_output()) {"Visualization of regional vote flows in the UK's European Union Referendum in 2016 using `sankeyNetwork()`"} else {"Visualization of regional vote flows in the UK's European Union Referendum in 2016 using `sankeyNetwork()`"}, out.width = if (knitr::is_latex_output()) "80%"}
if (knitr::is_html_output()) {
  library(dplyr)
  library(networkD3)
  library(tidyr)
  
  # get data
  eu_referendum <- read.csv("https://ona-book.org/data/eu_referendum.csv")
  
  # aggregate by region
  results <- eu_referendum |>  
    dplyr::group_by(Region) |> 
    dplyr::summarise(Remain = sum(Remain), Leave = sum(Leave)) |> 
    tidyr::pivot_longer( -Region, names_to = "result", values_to = "votes")
  
  # create unique regions, "Leave" and "Remain" for nodes dataframe
  regions <- unique(results$Region)
  nodes <- data.frame(node = c(0:13), 
                    name = c(regions, "Leave", "Remain"))
  
  #create edges/links dataframe
  results <- results |> 
    dplyr::inner_join(nodes, by = c("Region" = "name")) |> 
    dplyr::inner_join(nodes, by = c("result" = "name"))
  
  links <- results[ , c("node.x", "node.y", "votes")]
  colnames(links) <- c("source", "target", "value")

  # visualize using sankeyNetwork
  networkD3::sankeyNetwork(
    Links = links, Nodes = nodes, Source = 'source', Target = 'target', 
    Value = 'value', NodeID = 'name', units = 'votes'
  )
} else {
  knitr::include_graphics("www/visualizing-graphs/eu-sankey.png")
}
```

`r if (knitr::is_latex_output()) '<!--'`
:::thinkahead
**Thinking ahead:** As we have shown in the examples in this section, the `networkD3` package offers useful, convenient ways for non-Javascript programmers to make use of many of the great capabilities of the D3 visualization library. See [https://christophergandrud.github.io/networkD3/](https://christophergandrud.github.io/networkD3/) for more examples. However, the package's customization potential is limited.  For those who can program in D3, the scope exists to create amazing interactive graph visualizations, with limitless customization potential.  In the more advanced chapters of this book we will look at an example of how to visualize a network of the characters in the TV show *Friends* by coding natively in Javascript.
:::
`r if (knitr::is_latex_output()) '-->'`

`r if (knitr::is_html_output()) '<!--'`
```{=latex}
\colorbox{babyblueeyes}{
\begin{minipage}{\textwidth}
\textbf{Thinking ahead:} As we have shown in the examples in this section, the \texttt{networkD3} package offers useful, convenient ways for non-Javascript programmers to make use of many of the great capabilities of the D3 visualization library. See \texttt{https://christophergandrud.github.io/networkD3/} for more examples. However, the package's customization potential is limited.  For those who can program in D3, the scope exists to create amazing interactive graph visualizations, with limitless customization potential.  In the more advanced chapters of this book we will look at an example of how to visualize a network of the characters in the TV show \textit{Friends} by coding natively in Javascript.
\end{minipage}
}
```
`r if (knitr::is_html_output()) '-->'`
